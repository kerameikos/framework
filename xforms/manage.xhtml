<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:xxforms="http://orbeon.org/oxf/xml/xforms" xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:fr="http://orbeon.org/oxf/xml/form-runner" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
	xmlns:dcterms="http://purl.org/dc/terms/" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/" xmlns:kon="https://kerameikos.org/ontology#"
	xmlns:res="http://www.w3.org/2005/sparql-results#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:crmsci="http://www.ics.forth.gr/isl/CRMsci/"
	xmlns:crmgeo="http://www.ics.forth.gr/isl/CRMgeo/" xmlns:crmarchaeo="http://www.cidoc-crm.org/cidoc-crm/CRMarchaeo/"
	xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#">
	<head>
		<title>Kerameikos: Manage Datasets</title>
		<link rel="stylesheet" href="/fr/style/bootstrap/css/bootstrap.css" type="text/css" />
		<link rel="stylesheet" href="/fr/style/form-runner-bootstrap-override.css" type="text/css" />
		<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" />
		<script type="text/javascript" src="https://netdna.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
		<link rel="shortcut icon" href="/ops/images/orbeon-icon-16.ico" />
		<link rel="icon" href="/ops/images/orbeon-icon-16.png" type="image/png" />
		<link rel="stylesheet" href="/apps/kerameikos/xforms/css/style.css" />

		<xforms:model>
			<!-- ***** RDF templates ***** -->
			<xforms:instance id="rdf" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi kerameikos">
				<rdf:RDF xmlns="" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"
					xmlns:edm="http://www.europeana.eu/schemas/edm/" xmlns:dcterms="http://purl.org/dc/terms/"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" xmlns:kid="https://kerameikos.org/id/"
					xmlns:kon="https://kerameikos.org/ontology#" xmlns:crmsci="http://www.ics.forth.gr/isl/CRMsci/"
					xmlns:crmarchaeo="http://www.cidoc-crm.org/cidoc-crm/CRMarchaeo/" xmlns:crmgeo="http://www.ics.forth.gr/isl/CRMgeo/"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"/>
			</xforms:instance>

			<xforms:instance id="void-rdf" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi kerameikos">
				<rdf:RDF xmlns="" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"
					xmlns:edm="http://www.europeana.eu/schemas/edm/" xmlns:dcterms="http://purl.org/dc/terms/"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" xmlns:kid="https://kerameikos.org/id/"
					xmlns:kon="https://kerameikos.org/ontology#">
					<void:Dataset rdf:about="https://discovernewfields.org/">
						<dcterms:title xml:lang="en">Indianapolis Musem of Art at Newfields</dcterms:title>
						<dcterms:description xml:lang="en">Greek vases in the Indianapolis Museum of Art</dcterms:description>
						<dcterms:publisher rdf:resource="https://kerameikos.org/id/ima_newfields"/>
						<!--<dcterms:license rdf:resource=""/>-->
						<dcterms:rights rdf:resource="http://rightsstatements.org/vocab/NoC-US/1.0/"/>
						<void:dataDump rdf:resource="https://kerameikos.org/rdf/test-import.json"/>
					</void:Dataset>
				</rdf:RDF>
			</xforms:instance>

			<xforms:instance id="places" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi kerameikos">
				<rdf:RDF xmlns="" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"
					xmlns:edm="http://www.europeana.eu/schemas/edm/" xmlns:dcterms="http://purl.org/dc/terms/"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" xmlns:kid="https://kerameikos.org/id/"
					xmlns:kon="https://kerameikos.org/ontology#" xmlns:crmsci="http://www.ics.forth.gr/isl/CRMsci/"
					xmlns:crmarchaeo="http://www.cidoc-crm.org/cidoc-crm/CRMarchaeo/" xmlns:crmgeo="http://www.ics.forth.gr/isl/CRMgeo/"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"/>
			</xforms:instance>

			<!-- RDF templates for harvesting -->
			<xforms:instance id="object" xxforms:exclude-result-prefixes="#all">
				<crm:E22_Man-Made_Object rdf:about=""> </crm:E22_Man-Made_Object>
			</xforms:instance>

			<xforms:instance id="accession-template" xxforms:exclude-result-prefixes="#all">
				<crm:P1_is_identified_by>
					<crm:E42_Identifier>
						<crm:P190_has_symbolic_content/>
						<crm:P2_has_type rdf:resource="http://vocab.getty.edu/aat/300312355"/>
					</crm:E42_Identifier>
				</crm:P1_is_identified_by>
			</xforms:instance>

			<xforms:instance id="title-template" xxforms:exclude-result-prefixes="#all">
				<crm:P1_is_identified_by>
					<crm:E33_E41_Linguistic_Appellation>
						<crm:P190_has_symbolic_content/>
						<crm:P2_has_type rdf:resource="http://vocab.getty.edu/aat/300404670"/>
					</crm:E33_E41_Linguistic_Appellation>
				</crm:P1_is_identified_by>
			</xforms:instance>

			<xforms:instance id="production-template" xxforms:exclude-result-prefixes="#all">
				<crm:P108i_was_produced_by>
					<crm:E12_Production/>
				</crm:P108i_was_produced_by>
			</xforms:instance>

			<xforms:instance id="timespan-template" xxforms:exclude-result-prefixes="#all">
				<crm:P4_has_time-span>
					<crm:E52_Time-Span>
						<crm:P82a_begin_of_the_begin rdf:datatype="http://www.w3.org/2001/XMLSchema#gYear"/>
						<crm:P82b_end_of_the_end rdf:datatype="http://www.w3.org/2001/XMLSchema#gYear"/>
					</crm:E52_Time-Span>
				</crm:P4_has_time-span>
			</xforms:instance>

			<xforms:instance id="dimension-template" xxforms:exclude-result-prefixes="#all">
				<crm:P43_has_dimension>
					<crm:E54_Dimension>
						<crm:P2_has_type rdf:resource=""/>
						<crm:P90_has_value rdf:datatype="http://www.w3.org/2001/XMLSchema#decimal"/>
						<crm:P91_has_unit rdf:resource="http://vocab.getty.edu/aat/300379098"/>
					</crm:E54_Dimension>
				</crm:P43_has_dimension>
			</xforms:instance>

			<xforms:instance id="representation-template" xxforms:exclude-result-prefixes="#all">
				<crm:P138i_has_representation>
					<crm:E36_Visual_Item rdf:about=""/>
				</crm:P138i_has_representation>
			</xforms:instance>

			<xforms:instance id="manifest-template" xxforms:exclude-result-prefixes="#all">
				<crm:P129i_is_subject_of>
					<crm:E73_Information_Object rdf:about=""/>
					<dcterms:format>application/ld+json;profile="http://iiif.io/api/presentation/2/context.json"</dcterms:format>
					<dcterms:conformsTo rdf:resource="http://iiif.io/api/presentation"/>
				</crm:P129i_is_subject_of>
			</xforms:instance>

			<!-- archaeological context -->
			<xforms:instance id="encounter-template" xxforms:exclude-result-prefixes="#all">
				<crmsci:S19_Encounter_Event>
					<crm:P7_took_place_at>
						<crm:E53_Place>
							<rdf:type rdf:resource="http://www.w3.org/2004/02/skos/core#Concept"/>
							<crm:P89_falls_within rdf:resource=""/>
						</crm:E53_Place>
					</crm:P7_took_place_at>
				</crmsci:S19_Encounter_Event>
			</xforms:instance>

			<xforms:instance id="place-template" xxforms:exclude-result-prefixes="#all">
				<crm:E53_Place rdf:about=""/>
			</xforms:instance>

			<xforms:instance id="spatialThing-template" xxforms:exclude-result-prefixes="#all">
				<crmgeo:SP5_Geometric_Place_Expression rdf:about="">
					<rdf:type rdf:resource="http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing"/>
					<crmgeo:Q9_is_expressed_in_terms_of rdf:resource="http://www.wikidata.org/entity/Q215848"/>
					<geo:lat rdf:datatype="http://www.w3.org/2001/XMLSchema#decimal"/>
					<geo:long rdf:datatype="http://www.w3.org/2001/XMLSchema#decimal"/>
					<crmgeo:asWKT rdf:datatype="http://www.opengis.net/ont/geosparql#wktLiteral"/>
				</crmgeo:SP5_Geometric_Place_Expression>
			</xforms:instance>

			<!-- errors or warnings -->
			<xforms:instance id="warnings" xxforms:exclude-result-prefixes="#all">
				<warnings xmlns=""></warnings>
			</xforms:instance>

			<xforms:instance id="errors" xxforms:exclude-result-prefixes="#all">
				<errors xmlns=""></errors>
			</xforms:instance>

			<!-- Concordance URIs -->
			<xforms:instance id="mappings" xxforms:exclude-result-prefixes="#all">
				<mappings xmlns=""></mappings>
			</xforms:instance>

			<!-- Matches made to findspots -->
			<xforms:instance id="findspot-matches" xxforms:exclude-result-prefixes="#all">
				<findspots xmlns=""></findspots>
			</xforms:instance>

			<!-- Linked Art JSON-LD instance -->
			<xforms:instance id="json" xxforms:exclude-result-prefixes="#all">
				<json></json>
			</xforms:instance>

			<!-- config and controls -->
			<xforms:instance id="config" xxforms:exclude-result-prefixes="#all">
				<xi:include href="../config.xml"/>
			</xforms:instance>

			<xforms:instance id="control-instance">
				<controls xmlns="">
					<status></status>
					<void_uri></void_uri>
					<dump_uri></dump_uri>
					<dataset></dataset>
					<gazetteer_uri></gazetteer_uri>
					<!--<license></license>-->
					<rights>http://rightsstatements.org/vocab/NoC-US/1.0/</rights>
					<validate-trigger>false</validate-trigger>
					<import-json-trigger>false</import-json-trigger>
				</controls>
			</xforms:instance>

			<xforms:instance id="languages">
				<xi:include href="instances/languages.xml"/>
			</xforms:instance>

			<xforms:instance id="rights">
				<xi:include href="instances/rights.xml"/>
			</xforms:instance>

			<xforms:instance id="licenses">
				<xi:include href="instances/licenses.xml"/>
			</xforms:instance>

			<!-- store the void:Datasets in their own instance to free up the SPARQL response for other data harvesting and validation -->
			<xforms:instance id="datasets">
				<rdf:RDF/>
			</xforms:instance>

			<xforms:instance id="collections" xxforms:exclude-result-prefixes="#all">
				<collections xmlns=""></collections>
			</xforms:instance>

			<!-- Wikidata properties -->
			<xforms:instance id="wikidata-properties" xxforms:exclude-result-prefixes="#all">
				<props xmlns="">
					<prop namespace="vocab.getty.edu">P1667</prop>
					<prop namespace="sws.geonames.org">P1566</prop>
					<prop namespace="data.ordnancesurvey.co.uk">P3120</prop>
					<prop namespace="pleiades.stoa.org">P1584</prop>
				</props>
			</xforms:instance>

			<!-- SPARQL instances -->
			<xforms:instance id="sparqlQuery">
				<query></query>
			</xforms:instance>

			<!-- preloaded instances -->
			<xforms:instance id="sparqlResponse">
				<sparql xmlns="http://www.w3.org/2005/sparql-results#"/>
			</xforms:instance>

			<!-- sparql update -->
			<xforms:instance id="sparqlUpdate-template">
				<templates xmlns="">
					<query id="delete-metadata">
						<![CDATA[PREFIX void:	<http://rdfs.org/ns/void#> 
DELETE {?s ?p ?o} WHERE { <DATASET> ?p ?o . ?s ?p ?o . FILTER (?s = <DATASET>)}]]>
					</query>
					<query id="delete-dump">
						<![CDATA[PREFIX crm:	<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX crmsci:	<http://www.ics.forth.gr/isl/CRMsci/>
PREFIX crmgeo:	<http://www.ics.forth.gr/isl/CRMgeo/>
PREFIX void:	<http://rdfs.org/ns/void#>
DELETE {?s ?p ?o} WHERE { 
{ ?object void:inDataset <DATASET> ;
    crmsci:O19i_was_object_found_by ?encounter .
  ?encounter a crmsci:S19_Encounter_Event ;
    crm:P7_took_place_at ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P108i_was_produced_by ?prod .
  ?prod crm:P9_consists_of/crm:P14_carried_out_by ?s .
  ?s crm:P15_was_influenced_by ?artist . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P108i_was_produced_by ?prod .
  ?prod crm:P4_has_time-span|crm:P9_consists_of ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P108i_was_produced_by ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P1_is_identified_by ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P43_has_dimension ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P138i_has_representation ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crm:P129i_is_subject_of ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
    crmsci:O19i_was_object_found_by ?s . ?s ?p ?o }
UNION { ?s void:inDataset <DATASET> . ?s ?p ?o}
}]]></query>
					<query id="delete-places">
						<![CDATA[PREFIX crm:	<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX crmsci:	<http://www.ics.forth.gr/isl/CRMsci/>
PREFIX crmgeo:	<http://www.ics.forth.gr/isl/CRMgeo/>
PREFIX skos:	<http://www.w3.org/2004/02/skos/core#>
DELETE {?s ?p ?o} WHERE { 
{ ?place skos:inScheme <http://www.wikidata.org/entity/> ;
    crm:P168_place_is_defined_by ?s . ?s ?p ?o }
UNION { ?s skos:inScheme <http://www.wikidata.org/entity/> . ?s ?p ?o}
}]]>
					</query>
				</templates>
			</xforms:instance>

			<xforms:instance id="sparqlUpdate">
				<query></query>
			</xforms:instance>

			<!-- sparql query templates -->
			<xforms:instance id="sparql-templates">
				<templates xmlns="">
					<query id="get-datasets"><![CDATA[PREFIX rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX skos:	<http://www.w3.org/2004/02/skos/core#>
CONSTRUCT {?uri rdf:type void:Dataset ; dcterms:publisher ?publisher; dcterms:title ?title ; void:dataDump ?dump}
WHERE {?uri a void:Dataset ; 
  dcterms:publisher | dcterms:publisher/skos:prefLabel ?publisher FILTER (isLiteral(?publisher)) .
  ?uri void:dataDump ?dump; 
  dcterms:title ?title FILTER (lang(?title) = "" || langMatches(lang(?title), "en")) }
ORDER BY ASC(?publisher) ASC(?title)]]></query>
					<query id="get-collections"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>
SELECT ?uri ?label WHERE {
  ?uri a crm:E40_Legal_Body ;
       skos:prefLabel ?label FILTER (langMatches(lang(?label), "en"))
} ORDER BY ASC(?label)]]></query>
					<query id="get-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
SELECT ?uri ?type WHERE {
  ?uri skos:closeMatch <%MATCH%> ;
  	   skos:inScheme <https://kerameikos.org/id/> ;
       rdf:type ?type FILTER (?type != skos:Concept)
}]]></query>
					<query id="ask-wikidata-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
ASK {
  <%MATCH%> skos:inScheme <http://www.wikidata.org/entity/>
}]]></query>
					<query id="get-wikidata-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
SELECT ?uri WHERE {
  ?uri skos:closeMatch <%MATCH%> ;
       skos:inScheme <http://www.wikidata.org/entity/>
}]]></query>
					<query id="query-wikidata-match"><![CDATA[CONSTRUCT {
  ?place a skos:Concept; 
  		   rdfs:label ?placeLabel;
           skos:closeMatch ?osgeo;
           skos:closeMatch ?tgn;
           skos:closeMatch ?geonames ;
           skos:closeMatch ?pleiades ; 
           skos:broader ?parent ;
           dct:coverage ?coord ;
           dct:type ?type .
}
WHERE {
  %STATEMENT% .
  OPTIONAL {?place wdt:P3120 ?osgeoid .
  	BIND (uri(concat("http://data.ordnancesurvey.co.uk/id/", ?osgeoid)) as ?osgeo)}
  OPTIONAL {?place wdt:P1667 ?tgnid .
  	BIND (uri(concat("http://vocab.getty.edu/tgn/", ?tgnid)) as ?tgn)}
  OPTIONAL {?place wdt:P1566 ?geonamesid .
  	BIND (uri(concat("https://sws.geonames.org/", ?geonamesid, "/")) as ?geonames)}
  OPTIONAL {?place wdt:P1584 ?pleiadesid .
  	BIND (uri(concat("https://pleiades.stoa.org/places/", ?pleiadesid)) as ?pleiades)}
  OPTIONAL {?place p:P625/ps:P625 ?coord}
  OPTIONAL {?place wdt:P131 ?parent}
  OPTIONAL {?place wdt:P31/wdt:P279+|wdt:P31 ?type . FILTER (?type = wd:Q486972)} #is human settlement
  OPTIONAL {?place wdt:P31 ?type FILTER (?type = wd:Q839954)} #archaeological site
  SERVICE wikibase:label {
	bd:serviceParam wikibase:language "en"
  }
}]]></query>
				</templates>
			</xforms:instance>

			<!-- ************* BINDINGS **********************-->
			<xforms:bind nodeset="instance('void-rdf')">
				<xforms:bind nodeset="void:Dataset">
					<xforms:bind nodeset="@rdf:about" required="true()" type="xs:anyURI" constraint="matches(., 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$')"/>
					<xforms:bind nodeset="dcterms:title" required="true()">
						<xforms:bind nodeset="@xml:lang"
							constraint="string-length(.) &gt; 0 and (count(parent::node()/parent::node()/dcterms:title/@xml:lang) = count(distinct-values(parent::node()/parent::node()/dcterms:title/@xml:lang)))"
						/>
					</xforms:bind>
					<xforms:bind nodeset="dcterms:description" required="true()">
						<xforms:bind nodeset="@xml:lang"
							constraint="string-length(.) &gt; 0 and (count(parent::node()/parent::node()/dcterms:description/@xml:lang) = count(distinct-values(parent::node()/parent::node()/dcterms:description/@xml:lang)))"
						/>
					</xforms:bind>
					<xforms:bind nodeset="dcterms:license"
						constraint="if (not(@rdf:resource)) then string-length(normalize-space(.)) &gt; 0 else string-length(normalize-space(.)) = 0"/>
					<xforms:bind nodeset="dcterms:rights"
						constraint="if (not(@rdf:resource)) then string-length(normalize-space(.)) &gt; 0 else string-length(normalize-space(.)) = 0"/>
					<xforms:bind nodeset="//@rdf:resource" type="xs:anyURI" required="true()"
						constraint="matches(., 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$')"/>
				</xforms:bind>
			</xforms:bind>

			<xforms:bind nodeset="instance('control-instance')">
				<xforms:bind id="validate-trigger" nodeset="validate-trigger" type="xs:boolean" readonly=". != true()"/>
				<xforms:bind id="import-json-trigger" nodeset="import-json-trigger" type="xs:boolean" readonly=". != true()"/>
				<xforms:bind nodeset="license" required="true()">
					<xforms:bind nodeset="@other" required="true()"/>
				</xforms:bind>
				<xforms:bind nodeset="rights" required="true()">
					<xforms:bind nodeset="@other" required="true()"/>
				</xforms:bind>
			</xforms:bind>

			<!-- **************** DYNAMIC VALIDATION CONTROLS ********************** -->
			<xforms:action ev:event="xxforms-invalid" ev:observer="void-rdf">
				<xforms:setvalue ref="instance('control-instance')/import-json-trigger" value="false()"/>
			</xforms:action>

			<xforms:action ev:event="xxforms-valid" ev:observer="void-rdf">
				<xforms:setvalue ref="instance('control-instance')/import-json-trigger" value="true()"/>
			</xforms:action>

			<!-- ************* SPARQL SUBMISSIONS **********************-->
			<xforms:submission id="submit-sparqlQuery" action="{instance('config')/sparql/query}?query={encode-for-uri(instance('sparqlQuery'))}&amp;output=xml"
				ref="instance('sparqlResponse')" replace="instance" method="get">
				<xforms:message ev:event="xforms-submit-error" level="modal">SPARQL query failed.</xforms:message>
			</xforms:submission>

			<xforms:submission id="delete-graph" action="{instance('config')/sparql/update}" ref="instance('sparqlUpdate')" serialization="text/plain"
				replace="none" method="post" mediatype="application/sparql-update">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Graph successfully deleted from
					endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">SPARQL update failed.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-void" action="{instance('config')/sparql/store}?default" ref="instance('void-rdf')" replace="none" method="post"
				mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted to endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post VoID metadata.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-dump" action="{instance('config')/sparql/store}?default" ref="instance('rdf')" replace="none" method="post"
				mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted to endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post data dump.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-places" action="{instance('config')/sparql/store}?default" ref="instance('places')" replace="none" method="post"
				mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted places to
					endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post places RDF.</xforms:message>
			</xforms:submission>

			<!-- ************************* LOAD RDF/XML ************************** -->
			<xforms:submission id="load-void" serialization="none" method="get" action="{instance('control-instance')/void_uri}" replace="instance"
				instance="void-rdf">
				<xforms:action ev:event="xforms-submit-error">
					<xforms:message level="modal">Unable to load VoID metadata RDF.</xforms:message>
				</xforms:action>
			</xforms:submission>

			<xforms:submission id="load-dump" serialization="none" method="get" action="{instance('control-instance')/dump_uri}" replace="instance"
				instance="rdf">
				<xforms:action ev:event="xforms-submit-error">
					<xforms:message level="modal">Unable to load VoID dump.</xforms:message>
				</xforms:action>

				<!-- evaluate the findspot URIs and align them with Wikidata -->
				<xforms:action ev:event="xforms-submit-done">
					<xforms:action
						xxforms:iterate="distinct-values(instance('rdf')//crmsci:O19i_was_object_found_by/descendant::crm:P89_falls_within/@rdf:resource)">
						<xforms:var name="uri" select="."/>
						<xforms:setvalue ref="instance('control-instance')/gazetteer_uri" value="$uri"/>

						<!-- only parse gazetteer URIs from Getty TGN, Wikidata, Geonames, Ordnance Survey, or Pleiades -->
						<xforms:action
							if="matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'wikidata.org') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org'))">
							
							<!-- if the findspot URI is not found in the matches instances, then execute a SPARQL query to see if the Place exists 
								in the Nomisma SPARQL endpoint already -->
							<xforms:action if="not(instance('findspot-matches')/findspot = $uri)">
								
								<!-- evaluate the URI to determine which SPARQL query to submit -->
								<xforms:setvalue ref="instance('sparqlQuery')"
									value="replace(instance('sparql-templates')/query[@id='ask-wikidata-match'], '%MATCH%', $uri)"
									if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
								<xforms:setvalue ref="instance('sparqlQuery')"
									value="replace(instance('sparql-templates')/query[@id='get-wikidata-match'], '%MATCH%', $uri)"
									if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
								<xforms:send submission="submit-sparqlQuery"/>
								
								<!-- if the URI is in the Nomisma.org SPARQL endpoint, add it to the findspot-matches instance -->
								<xforms:action if="count(instance('sparqlResponse')//res:result) &gt; 0">
									<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
										origin="xforms:element('findspot', (xforms:attribute('matches', instance('sparqlResponse')//res:result[1]/res:binding[@name='uri']/res:uri), $uri))"
									/>
								</xforms:action>
								
								<xforms:action if="instance('sparqlResponse')//res:boolean = true()">
									<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
										origin="xforms:element('findspot', $uri)"/>
								</xforms:action>
								
								<!-- if the URI isn't in the Nomisma.org SPARQL endpoint, then execute Wikidata SPARQL queries to generate E53_Place nodes, coordinates, and hierarchy -->
								<xforms:action
									if="(not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')) and count(instance('sparqlResponse')//res:result) = 0) or
									(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$') and instance('sparqlResponse')//res:boolean = false())">									
									
									<xforms:var name="id"
										select="if (contains($uri, 'sws.geonames.org')) then tokenize($uri, '/')[last() - 1] else tokenize($uri, '/')[last()]"/>
									<xforms:var name="namespace" select="tokenize($uri, '/')[3]"/>
									<xforms:var name="prop" select="instance('wikidata-properties')/prop[@namespace = $namespace]"/>
									
									<!-- set the SPARQL query, depending on URI -->
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('?place wdt:', $prop, ' &#x022;', $id, '&#x022;'))"
										if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('BIND (wd:', $id, ' as ?place)'))"
										if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
									<xforms:send submission="query-wikidata"/>
								</xforms:action>
							</xforms:action>
						</xforms:action>
					</xforms:action>
					
					<!-- after the RDF dump is loaded and the findspot places have been reconciled to Wikidata, then replace
														non Wikidata URIs associated with findspots -->
					<xforms:action xxforms:iterate="instance('rdf')//crmsci:O19i_was_object_found_by/descendant::crm:P89_falls_within">
						<xforms:var name="uri" select="context()/@rdf:resource"/>
						
						<xforms:action
							if="matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org'))">
							
							<xforms:setvalue ref="context()/@rdf:resource" value="instance('findspot-matches')/findspot[. = $uri]/@matches"
								if="instance('findspot-matches')/findspot[. = $uri]/@matches"/>
						</xforms:action>						
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<!-- ************************* QUERY WIKIDATA SPARQL ENDPOINT ************************** -->
			<xforms:submission id="query-wikidata" action="https://query.wikidata.org/sparql?query={encode-for-uri(instance('sparqlQuery'))}"
				ref="instance('sparqlResponse')" replace="instance" method="get">
				<xforms:header>
					<xforms:name>Accept</xforms:name>
					<xforms:value>application/rdf+xml</xforms:value>
				</xforms:header>
				<xforms:header>
					<xforms:name>User-Agent</xforms:name>
					<xforms:value>XForms/Kerameikos.org</xforms:value>
				</xforms:header>
				<xforms:message ev:event="xforms-submit-error" level="modal">Wikidata SPARQL query failed.</xforms:message>

				<!-- after a query is sent to Wikidata, write the resulting RDF from Wikidata into the Kerameikos ingest -->
				<xforms:action ev:event="xforms-submit-done">
					<xforms:var name="q-valid" select="if (count(instance('sparqlResponse')/rdf:Description) = 1) then true() else false()"/>
					
					<!-- MATCH FOUND IN WIKIDATA: 
										if there is a resulting Q Entity in Wikidata, then insert the findspot into the matches instance and 
										generate subsquent place nodes in the Nomisma SPARQL endpoint -->
					<xforms:action if="$q-valid = true()">
						<xforms:var name="q_entity" select="data(instance('sparqlResponse')/rdf:Description/@rdf:about)"/>
						
						<xforms:action if="not(instance('findspot-matches')/findspot = $q_entity) and not(instance('findspot-matches')/findspot[@matches = $q_entity])">
							
							<!-- insert E53_Place and set related metadata -->
							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('place-template')"/>
							<xforms:setvalue ref="instance('places')/crm:E53_Place[last()]/@rdf:about" value="$q_entity"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="instance('sparqlResponse')//skos:closeMatch"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="xforms:element('rdfs:label', data(instance('sparqlResponse')//rdfs:label[1]))"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="xforms:element('skos:inScheme', xforms:attribute('rdf:resource', 'http://www.wikidata.org/entity/'))"/>
							
							<!-- reset value of Geonames to append forward slash because Wikidata SPARQL will not concatenate it -->
							<xforms:setvalue
								ref="instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource"
								value="concat(instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource, '/')"
								if="not(ends-with(instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource, '/'))"/>
							
							<!-- if there are coordinates and the place has a subtype of human settlement/archaeological site, insert the geo: and crm: properties and the spatialThing template -->
							<xforms:action
								if="instance('sparqlResponse')/rdf:Description/dcterms:coverage and instance('sparqlResponse')/rdf:Description/dcterms:type">
								<xforms:var name="geoURI" select="concat($q_entity, '#this')"/>
								<xforms:var name="coords" select="instance('sparqlResponse')/rdf:Description/dcterms:coverage[1]"/>
								
								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('geo:location', xforms:attribute('rdf:resource', $geoURI))"/>
								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('crm:P168_place_is_defined_by', xforms:attribute('rdf:resource', $geoURI))"/>
								
								<!-- set geo: and crmgeo: properties -->
								<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('spatialThing-template')"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/@rdf:about" value="$geoURI"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/crmgeo:asWKT" value="$coords"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/geo:long"
									value="tokenize(substring-before(substring-after($coords, '('), ')'), ' ')[1]"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/geo:lat"
									value="tokenize(substring-before(substring-after($coords, '('), ')'), ' ')[2]"/>
							</xforms:action>
							
							<!-- perform a hierarchical Wikidata SPARQL query in order to generate E53_Places for each parent of the Q entity -->
							<xforms:action xxforms:iterate="instance('sparqlResponse')//skos:broader">
								<xforms:var name="parentURI" select="data(@rdf:resource)"/>
								
								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('crm:P89_falls_within', xforms:attribute('rdf:resource', $parentURI))"/>
								
								<!-- only execute Wikidata SPARQL query for a parent URI if it isn't already in the places RDF instance -->
								<xforms:action if="not(instance('places')/crm:E53_Place[@rdf:about = $parentURI])">
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('BIND (wd:', tokenize($parentURI, '/')[last()], ' as ?place)'))"
										if="matches($parentURI, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
									
									<xforms:send submission="query-wikidata"/>
								</xforms:action>
							</xforms:action>
						</xforms:action>
						
						<!-- insert findspot concordance into matches instance to prevent further lookups for this URI -->
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
							origin="xforms:element('findspot', $q_entity)" if="$q_entity = instance('control-instance')/gazetteer_uri"/>
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
							origin="xforms:element('findspot', (xforms:attribute('matches', $q_entity), data(instance('control-instance')/gazetteer_uri)))"
							if="not($q_entity = instance('control-instance')/gazetteer_uri)"/>
						
					</xforms:action>
					
					<!-- MATCH NOT FOUND IN WIKIDATA: 
										if the matching URI is not found, then insert an error about the lack of a match to Wikidata -->
					<xforms:action if="$q-valid = false()">
						<xforms:insert context="instance('errors')" nodeset="./child::node()[last()]"
							origin="xforms:element('error', concat('The findspot URI ', instance('control-instance')/gazetteer_uri, ' does not resolve to a Wikidata Q entity. The corresponding Wikidata entity may need to be updated.'))"/>
						
						<!-- insert the findspot URI into the instance('findspot-matches') to prevent additional lookups -->
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
							origin="xforms:element('findspot', data(instance('control-instance')/gazetteer_uri))"/>
						
						<!-- if a place of this URI exists in the dump, move it to the places instance -->
						<xforms:action if="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]">
							<xforms:var name="spatial-uri" select="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]/geo:location/@rdf:resource"/>
							
							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]"/>
							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('rdf')//*[@rdf:about = $spatial-uri]"/>
							
							<!-- set the concept scheme -->
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]" nodeset="./child::node()[last()]"
								origin="xforms:element('skos:inScheme', xforms:attribute('rdf:resource', concat(tokenize(instance('control-instance')/gazetteer_uri, '/')[1], '://', tokenize(instance('control-instance')/gazetteer_uri, '/')[3], '/')))"/>
							
							<!-- then delete the above objects from the RDF dump -->
							<xforms:delete nodeset="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]"/>
							<xforms:delete nodeset="instance('rdf')//*[@rdf:about = $spatial-uri]"/>
						</xforms:action>
					</xforms:action>
				</xforms:action>

			</xforms:submission>

			<!-- ************************* LOAD LINKED ART JSON-LD ************************** -->
			<xforms:submission id="load-json" serialization="none" method="get" action="{instance('void-rdf')/void:Dataset/void:dataDump/@rdf:resource}"
				replace="instance" instance="json">
				<xforms:action ev:event="xforms-submit-error">
					<xforms:message level="modal">Unable to load JSON-LD. Either it is not JSON or the URL is incorrect.</xforms:message>
				</xforms:action>

				<!-- iterate through each JSON Human-Made-Object at the level of each API call -->
				<xforms:action ev:event="xforms-submit-done">
					<!-- extract all possible URIs and execute SPARQL queries to get their Kerameikos.org exactMatch, if applicable -->
					<xforms:action
						xxforms:iterate="distinct-values(instance('json')//produced_by/carried_out_by/_/id|instance('json')//produced_by/took_place_at/_/id|instance('json')//made_of/_/id|instance('json')//technique/_/id|instance('json')/descendant-or-self::node()[type='HumanMadeObject']/classified_as/_/id|instance('json')//current_owner/id|instance('json')//style/_/id)">
						<xforms:var name="val" select="normalize-space(data(context()))"/>
						<xforms:var name="uri"
							select="if (starts-with($val, 'aat:') or starts-with($val, 'ulan:') or starts-with($val, 'tgn:')) then concat('http://vocab.getty.edu/', substring-before($val, ':'), '/', substring-after($val, ':'))
							else $val"/>

						<!-- perform lookup only if the URI hasn't already been mapped (applicable for eventual API pagination) -->
						<xforms:action if="not(instance('mappings')/mapping[@from = $uri]/@to)">
							<!-- set the SPARQL query-->
							<xforms:setvalue ref="instance('sparqlQuery')" value="replace(instance('sparql-templates')/query[@id='get-match'], '%MATCH%', $uri)"/>
							<xforms:send submission="submit-sparqlQuery"/>

							<!-- if there's a response, then insert the corresponding Kerameikos URI and class -->
							<xforms:action if="instance('sparqlResponse')//res:result">
								<xforms:insert context="instance('mappings')" nodeset="./child::node()[last()]"
									origin="xforms:element('mapping', (xforms:attribute('from', $uri), xforms:attribute('to', instance('sparqlResponse')//res:binding[@name='uri']/res:uri), xforms:attribute('type', instance('sparqlResponse')//res:binding[@name='type']/res:uri)))"
								/>
							</xforms:action>
							<!-- otherwise insert a mapping @from without a @to to prevent further HTTP requests -->
							<xforms:action if="not(instance('sparqlResponse')//res:result)">
								<xforms:insert context="instance('mappings')" nodeset="./child::node()[last()]"
									origin="xforms:element('mapping', (xforms:attribute('from', $uri)))"/>
							</xforms:action>
						</xforms:action>
					</xforms:action>

					<!-- iterate though findspot URIs and perform Wikidata SPARQL queries to get matching URIs and coordinates, if applicable -->
					<xforms:action xxforms:iterate="distinct-values(instance('json')//encountered/took_place_at/part_of/_/id)">
						<xforms:var name="val" select="normalize-space(data(context()))"/>
						<xforms:var name="uri"
							select="if (starts-with($val, 'tgn:')) then concat('http://vocab.getty.edu/tgn/', substring-after($val, ':'))
							else $val"/>
						<xforms:setvalue ref="instance('control-instance')/gazetteer_uri" value="$uri"/>

						<!-- only parse gazetteer URIs from Getty TGN, Wikidata, Geonames, Ordnance Survey, or Pleiades -->
						<xforms:action
							if="matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'wikidata.org') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org'))">

							<!-- if the findspot URI is not found in the matches instances, then execute a SPARQL query to see if the Place exists 
								in the Kerameikos SPARQL endpoint already -->
							<xforms:action if="not(instance('findspot-matches')/findspot = $uri)">

								<!-- evaluate the URI to determine which SPARQL query to submit -->
								<xforms:setvalue ref="instance('sparqlQuery')"
									value="replace(instance('sparql-templates')/query[@id='ask-wikidata-match'], '%MATCH%', $uri)"
									if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
								<xforms:setvalue ref="instance('sparqlQuery')"
									value="replace(instance('sparql-templates')/query[@id='get-wikidata-match'], '%MATCH%', $uri)"
									if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
								<xforms:send submission="submit-sparqlQuery"/>

								<!-- if the URI is in the Kerameikos.org SPARQL endpoint, add it to the findspot-matches instance -->
								<xforms:action if="count(instance('sparqlResponse')//res:result) &gt; 0 or instance('sparqlResponse')//res:boolean = true()">
									<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
										origin="xforms:element('findspot', (xforms:attribute('matches', data(instance('sparqlResponse')//res:result/res:binding[@name='uri']/res:uri)), $uri))"
									/>
								</xforms:action>

								<!-- if the URI isn't in the Kerameikos.org SPARQL endpoint, then execute Wikidata SPARQL queries to generate E53_Place nodes, coordinates, and hierarchy -->
								<xforms:action
									if="(not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')) and count(instance('sparqlResponse')//res:result) = 0) or
									(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$') and instance('sparqlResponse')//res:boolean = false())">
									<xforms:var name="id"
										select="if (contains($uri, 'sws.geonames.org')) then tokenize($uri, '/')[last() - 1] else tokenize($uri, '/')[last()]"/>
									<xforms:var name="namespace" select="tokenize($uri, '/')[3]"/>
									<xforms:var name="prop" select="instance('wikidata-properties')/prop[@namespace = $namespace]"/>

									<!-- set the SPARQL query, depending on URI -->
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('?place wdt:', $prop, ' &#x022;', $id, '&#x022;'))"
										if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('BIND (wd:', $id, ' as ?place)'))"
										if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
									<xforms:send submission="query-wikidata"/>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- if the URI doesn't conform to a parseable entity, then insert a warning -->
						<xforms:action
							if="not(matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'wikidata.org') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org')))">
							<xforms:insert context="instance('warnings')" nodeset="./child::node()[last()]"
								origin="xforms:element('warning', concat('The findspot URI ', $uri, ' is not an allowable gazetteer.'))"/>
							<!-- insert the findspot URI into the instance('findspot-matches') to prevent additional lookups -->
							<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]" origin="xforms:element('findspot', $uri)"/>
						</xforms:action>
					</xforms:action>

					<!-- interate through all HMOs in the JSON-LD response -->
					<xforms:action xxforms:iterate="instance('json')/descendant-or-self::node()[type='HumanMadeObject']">
						<!-- use the home page link when available, otherwise use the URI for the HMO -->
						<xforms:var name="objectURI"
							select="if (context()/subject_of/_[classified_as/_/id = 'http://vocab.getty.edu/aat/300266277'])
							then context()/subject_of/_[classified_as/_/id = 'http://vocab.getty.edu/aat/300266277']/id else context()/id"/>

						<xforms:setvalue ref="instance('object')/@rdf:about" value="$objectURI"/>

						<!-- Identifiers: Title and Accession number -->
						<xforms:action xxforms:iterate="context()/identified_by/_">
							<xforms:var name="content" select="context()/content"/>

							<xforms:action if="context()/classified_as/_/id = 'http://vocab.getty.edu/aat/300404670'">
								<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('title-template')"/>
								<xforms:setvalue
									ref="instance('object')/crm:P1_is_identified_by[last()]/crm:E33_E41_Linguistic_Appellation/crm:P190_has_symbolic_content"
									value="$content"/>
							</xforms:action>
							<xforms:action if="context()/classified_as/_/id = 'http://vocab.getty.edu/aat/300312355'">
								<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('accession-template')"/>
								<xforms:setvalue ref="instance('object')/crm:P1_is_identified_by[last()]/crm:E42_Identifier/crm:P190_has_symbolic_content"
									value="$content"/>
							</xforms:action>
						</xforms:action>

						<!-- iterate through types in order to parse the shape -->
						<xforms:action xxforms:iterate="context()/classified_as/_[@type='object']">
							<xforms:var name="uri" select="context()/id"/>

							<xforms:action if="instance('mappings')/mapping[@from = $uri]/@type = 'https://kerameikos.org/ontology#Shape'">
								<xforms:var name="match" select="instance('mappings')/mapping[@from = $uri]/@to"/>

								<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
									origin="xforms:element('kon:hasShape', (xforms:attribute('rdf:resource', $match)))"/>
							</xforms:action>
						</xforms:action>

						<!-- iterate through visual item depictions to parse out styles -->
						<xforms:action xxforms:iterate="context()/shows/_[child::style]/style//id">
							<xforms:var name="uri" select="data(context())"/>
							<xforms:var name="match"
								select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('kon:hasStyle', (xforms:attribute('rdf:resource', $match)))"/>
						</xforms:action>

						<!-- create material property -->
						<xforms:action xxforms:iterate="context()/made_of/_">
							<xforms:var name="uri" select="context()/id"/>

							<xforms:var name="match"
								select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('crm:P45_consists_of', (xforms:attribute('rdf:resource', $match)))"/>
						</xforms:action>



						<!-- begin processing production event, if applicable -->
						<xforms:action if="context()/produced_by">
							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('production-template')"/>

							<!-- iterate through all production properties -->
							<xforms:action xxforms:iterate="context()/produced_by/*">
								<xforms:var name="property" select="context()/name()"/>

								<xforms:action if="$property = 'carried_out_by'">
									<xforms:action xxforms:iterate="context()/_">
										<xforms:var name="uri" select="context()/id"/>
										<xforms:var name="match"
											select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

										<xforms:insert context="instance('object')/crm:P108i_was_produced_by/crm:E12_Production"
											nodeset="./child::node()[last()]"
											origin="xforms:element('crm:P14_carried_out_by', (xforms:attribute('rdf:resource', $match)))"/>
									</xforms:action>
								</xforms:action>

								<xforms:action xxforms:iterate="$property = 'technique'">
									<xforms:action xxforms:iterate="context()/_">
										<xforms:var name="uri" select="context()/id"/>
										<xforms:var name="match"
											select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

										<xforms:insert context="instance('object')/crm:P108i_was_produced_by/crm:E12_Production"
											nodeset="./child::node()[last()]"
											origin="xforms:element('crm:P32_used_general_technique', (xforms:attribute('rdf:resource', $match)))"/>
									</xforms:action>
								</xforms:action>

								<xforms:action if="$property = 'took_place_at'">
									<xforms:action xxforms:iterate="context()/_">
										<xforms:var name="uri" select="context()/id"/>
										<xforms:var name="match"
											select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

										<xforms:insert context="instance('object')/crm:P108i_was_produced_by/crm:E12_Production"
											nodeset="./child::node()[last()]"
											origin="xforms:element('crm:P7_took_place_at', (xforms:attribute('rdf:resource', $match)))"/>
									</xforms:action>
								</xforms:action>
								<xforms:action if="$property = 'timespan'">
									<!-- only process timespan if there's a start and end, and they conform to xsd:dateTime -->

									<xforms:action
										if="context()/begin_of_the_begin castable as xs:dateTime and context()/end_of_the_end castable as xs:dateTime">
										<!-- convert to xsd:gYear -->
										<xforms:var name="begin"
											select="if (starts-with(context()/begin_of_the_begin, '-')) then substring(context()/begin_of_the_begin, 1, 5) else substring(context()/begin_of_the_begin, 1, 4)"/>
										<xforms:var name="end"
											select="if (starts-with(context()/end_of_the_end, '-')) then substring(context()/end_of_the_end, 1, 5) else substring(context()/end_of_the_end, 1, 4)"/>

										<xforms:insert context="instance('object')/crm:P108i_was_produced_by/crm:E12_Production"
											nodeset="./child::node()[last()]" origin="instance('timespan-template')"/>

										<xforms:setvalue ref="instance('object')/crm:P108i_was_produced_by//crm:P82a_begin_of_the_begin"
											value="if (number($begin) &lt; 0) then format-number(number($begin) - 1, '0000') else $begin"/>
										<xforms:setvalue ref="instance('object')/crm:P108i_was_produced_by//crm:P82b_end_of_the_end"
											value="if (number($end) &lt; 0) then format-number(number($end) - 1, '0000') else $end"/>
									</xforms:action>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- insert and convert dimensions to metric -->
						<xforms:action if="count(context()/dimension/_) &gt; 0">
							<xforms:action xxforms:iterate="context()/dimension/_">

								<!-- ensure that the value is numeric -->
								<xforms:action if="context()/value castable as xs:decimal">
									<xforms:var name="units" select="context()/unit/id"/>
									<xforms:var name="val" select="number(context()/value)"/>

									<!-- insert the dimension template, but only if the units conform to AAT -->
									<xforms:action if="matches($units, 'https?://vocab.getty.edu/aat/\d+')">
										<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('dimension-template')"/>

										<!-- set the dimension type -->
										<xforms:setvalue ref="instance('object')/crm:P43_has_dimension[last()]/crm:E54_Dimension/crm:P2_has_type/@rdf:resource"
											value="context()/classified_as/_[1]/id"/>

										<!-- perform some math to convert inches to centimeters, if applicable -->
										<xforms:action if="$units = 'http://vocab.getty.edu/aat/300379100'">
											<!-- inches -->
											<xforms:setvalue ref="instance('object')/crm:P43_has_dimension[last()]/crm:E54_Dimension/crm:P90_has_value"
												value="format-number($val * 2.54, '###.##')"/>
										</xforms:action>
										<xforms:action if="$units = 'http://vocab.getty.edu/aat/300379098'">
											<!-- cm -->
											<xforms:setvalue ref="instance('object')/crm:P43_has_dimension[last()]/crm:E54_Dimension/crm:P90_has_value"
												value="$val"/>
										</xforms:action>
									</xforms:action>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- archaeological context, if applicable -->
						<xforms:action if="context()/encountered[took_place_at/part_of/_/id]">
							<xforms:var name="uri" select="if (context()/encountered/id) then context()/encountered/id else concat($objectURI, '#discovery')"/>
							<xforms:var name="gazetteerURI" select="context()/encountered/took_place_at/part_of/_[1]/id"/>

							<!-- insert property into object -->
							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('crmsci:O19i_was_object_found_by', (xforms:attribute('rdf:resource', $uri)))"/>

							<!-- insert Encounter Event into instance('rdf') if it doesn't already exist (multiple objects can theoretically be tied to one Encounter) -->
							<xforms:action if="not(instance('rdf')/crmsci:S19_Encounter_Event[@rdf:about = $uri])">
								<xforms:insert context="instance('rdf')" nodeset="./child::node()[last()]" origin="instance('encounter-template')"/>
								<xforms:insert context="instance('rdf')/crmsci:S19_Encounter_Event[last()]" origin="xforms:attribute('rdf:about', $uri)"/>

								<!-- *** S19_Encounter_Event processing *** -->


								<!-- *** E53_Place processing *** -->
								<!-- insert URI into crm:E53_Place if applicable -->
								<xforms:action if="matches(context()/encountered/took_place_at/id, 'https?://')">
									<xforms:var name="$placeURI" select="data(context()/encountered/took_place_at/id)"/>

									<xforms:insert context="instance('rdf')/crmsci:S19_Encounter_Event[last()]/crm:P7_took_place_at/crm:E53_Place"
										origin="xforms:attribute('rdf:about', $placeURI)"/>
								</xforms:action>

								<!-- insert optional label into E53_Place -->
								<xforms:action if="string(context()/encountered/took_place_at/_label)">
									<xforms:var name="label" select="data(context()/encountered/took_place_at/_label)"/>

									<xforms:insert context="instance('rdf')/crmsci:S19_Encounter_Event[last()]/crm:P7_took_place_at/crm:E53_Place"
										origin="xforms:element('rdfs:label', $label)"/>
								</xforms:action>

								<!-- insert types of place -->
								<xforms:action xxforms:iterate="context()/encountered/took_place_at/classified_as/_">
									<xforms:var name="type" select="data(context()/id)"/>

									<xforms:insert context="instance('rdf')/crmsci:S19_Encounter_Event[last()]/crm:P7_took_place_at/crm:E53_Place"
										nodeset="./child::node()[last()]" origin="xforms:element('crm:P2_has_type', xforms:attribute('rdf:resource', $type))"/>
								</xforms:action>

								<!-- if the gazetteer URI has already been validated upon JSON load, then insert the part_of property (if there's a corresponding @matches) -->
								<xforms:action if="instance('findspot-matches')/findspot[. = $gazetteerURI]/@matches">
									<!-- set parent gazetteer URI -->
									<xforms:setvalue
										ref="instance('rdf')/crmsci:S19_Encounter_Event[last()]/crm:P7_took_place_at/crm:E53_Place/crm:P89_falls_within/@rdf:resource"
										value="instance('findspot-matches')/findspot[. = $gazetteerURI]/@matches"/>
								</xforms:action>

								<!-- if the gazetteer URI is not one of the parseable services, simply insert the URI -->
								<xforms:action if="not(instance('findspot-matches')/findspot[. = $gazetteerURI]/@matches)">
									<!-- set parent gazetteer URI -->
									<xforms:setvalue
										ref="instance('rdf')/crmsci:S19_Encounter_Event[last()]/crm:P7_took_place_at/crm:E53_Place/crm:P89_falls_within/@rdf:resource"
										value="$gazetteerURI"/>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- digital images -->
						<xforms:action xxforms:iterate="context()/representation/_">
							<xforms:var name="binding" select="context()" as="node()?"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('representation-template')"/>
							<xforms:setvalue ref="instance('object')/crm:P138i_has_representation[last()]/crm:E36_Visual_Item/@rdf:about" value="$binding/id"/>

							<!-- insert label, if applicable -->
							<xforms:insert context="instance('object')/crm:P138i_has_representation[last()]/crm:E36_Visual_Item"
								nodeset="./child::node()[last()]" origin="xforms:element('rdfs:label', data($binding/_label))"
								if="string(data($binding/_label))"/>

							<!-- evaluate classified_as or conforms_to as image or IIIF -->
							<xforms:insert context="instance('object')/crm:P138i_has_representation[last()]/crm:E36_Visual_Item"
								nodeset="./child::node()[last()]"
								origin="xforms:element('dcterms:conformsTo', (xforms:attribute('rdf:resource', 'http://iiif.io/api/image')))"
								if="$binding/conforms_to"/>
							<xforms:insert context="instance('object')/crm:P138i_has_representation[last()]/crm:E36_Visual_Item"
								nodeset="./child::node()[last()]" origin="xforms:element('dcterms:format', 'image/jpeg')" if="$binding/classified_as"/>
						</xforms:action>

						<!-- if there's a IIIF Manifest link -->
						<xforms:action if="context()/subject_of/_[conforms_to/_/id = 'http://iiif.io/api/presentation']">
							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="instance('manifest-template')"/>
							<xforms:setvalue ref="instance('object')/crm:P129i_is_subject_of[last()]/crm:E73_Information_Object/@rdf:about"
								value="context()/subject_of/_[conforms_to/_/id = 'http://iiif.io/api/presentation']/id"/>
						</xforms:action>

						<!-- insert collection link -->
						<xforms:action if="context()/current_owner">
							<xforms:var name="uri" select="context()/current_owner/id"/>
							<xforms:var name="match"
								select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('crm:P50_has_current_keeper', (xforms:attribute('rdf:resource', $match)))"/>
						</xforms:action>

						<!-- insert void:inDataset -->
						<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
							origin="xforms:element('void:inDataset', (xforms:attribute('rdf:resource', data(instance('void-rdf')/void:Dataset/@rdf:about))))"/>

						<!-- insert HMO template into primary RDF instance after processing -->
						<xforms:insert context="instance('rdf')" nodeset="child::node()[last()]" origin="instance('object')"/>

						<!-- clear template after completion -->
						<xforms:delete nodeset="instance('object')/*"/>
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<!-- ********** XFORMS-MODEL-CONSTRUCT-DONE ********** -->
			<xforms:action ev:event="xforms-model-construct-done">
				<!-- populate the page with a list of current collections ingested into Kerameikos -->
				<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
				<xforms:send submission="submit-sparqlQuery"/>
				<xforms:delete nodeset="instance('datasets')/*"/>
				<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
			</xforms:action>

			<!-- **************** XFORMS-READY ********************** -->
			<xforms:action ev:event="xforms-ready">
				<!-- enable import trigger if the document is valid on ready -->

				<!-- can be disabled after testing -->
				<xforms:setvalue ref="instance('control-instance')/import-json-trigger" value="true()" if="xxforms:valid(instance('void-rdf'), true())"/>
			</xforms:action>
		</xforms:model>
	</head>

	<body>
		<xforms:var name="display_path">../</xforms:var>
		<div class="container-fluid">
			<div class="row">
				<div class="col-md-3 pull-right text-right">
					<h4>
						<a href="logout"><span class="glyphicon glyphicon-log-out"></span> logout</a>
					</h4>
				</div>
			</div>
			<div class="row">
				<div class="col-md-12">
					<p><a href="../"><span class="glyphicon glyphicon-arrow-left"></span>Return to Admin</a></p>
					<xforms:group ref=".[string-length(instance('control-instance')/status) &gt; 0]">
						<div class="alert alert-success alert-box">
							<span class="glyphicon glyphicon-info-sign"></span>
							<strong>Status:</strong>
							<xforms:output ref="instance('control-instance')/status"/>
						</div>
					</xforms:group>
					<h1>Manage Datasets</h1>
					<div>
						<xforms:trigger appearance="minimal">
							<xforms:label><span class="glyphicon glyphicon-plus"></span>Add dataset via RDF/XML VoID</xforms:label>
							<xforms:action ev:event="DOMActivate">
								<xforms:setvalue ref="instance('control-instance')/void_uri"/>
								<xxforms:show dialog="lookup-dialog"/>
							</xforms:action>
						</xforms:trigger>
						<xforms:trigger appearance="minimal">
							<xforms:label><span class="glyphicon glyphicon-plus"></span>Harvest Linked Art JSON-LD</xforms:label>
							<xforms:action ev:event="DOMActivate">
								<!-- submit SPARQL query to get a list of existing collections to use as dcterms:publisher -->
								<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-collections']"/>
								<xforms:send submission="submit-sparqlQuery"/>

								<xforms:action ev:event="xforms-submit-done">
									<xforms:action xxforms:iterate="instance('sparqlResponse')//res:result">
										<xforms:var name="uri" select="data(context()/res:binding[@name='uri']/res:uri)"/>
										<xforms:var name="label" select="data(context()/res:binding[@name='label']/res:literal)"/>

										<xforms:insert context="instance('collections')" nodeset="./child::node()[last()]"
											origin="xforms:element('collection', (xforms:attribute('uri', $uri), $label))"/>
									</xforms:action>

									<!-- toggle interface -->
									<xforms:toggle case="harvest-json"/>
								</xforms:action>
							</xforms:action>
						</xforms:trigger>
					</div>
					<xforms:switch>
						<xforms:case id="default">
							<xforms:group ref="instance('datasets')">
								<xforms:group ref=".[count(rdf:Description) &gt; 0]">
									<table class="table">
										<thead>
											<tr>
												<th>Dataset</th>
												<th>Publisher</th>
												<th>Refresh</th>
												<th>Delete</th>
											</tr>
										</thead>
										<tbody>
											<xforms:repeat nodeset="descendant::rdf:Description">
												<tr>
													<td>
														<xforms:trigger appearance="minimal">
															<xforms:label value="dcterms:title"/>
															<xforms:action ev:event="DOMActivate">
																<xforms:load show="new" resource="{@rdf:about}"/>
															</xforms:action>
														</xforms:trigger>
													</td>
													<td><xforms:output ref="dcterms:publisher"/></td>
													<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-refresh"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:dispatch target="refresh-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>
													<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-remove"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:dispatch target="delete-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>
												</tr>
											</xforms:repeat>
										</tbody>
									</table>
								</xforms:group>
								<xforms:group ref=".[count(void:Dataset) = 0]">
									<p>No datasets found in endpoint. <xforms:trigger appearance="minimal">
											<xforms:label>Add a dataset.</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:setvalue ref="instance('control-instance')/void_uri"/>
												<xxforms:show dialog="lookup-dialog"/>
											</xforms:action>
										</xforms:trigger></p>
								</xforms:group>
							</xforms:group>
						</xforms:case>
						<xforms:case id="harvest-json">
							<xforms:group ref="instance('void-rdf')/void:Dataset">

								<xforms:group ref=".[not(count(dcterms:title/@xml:lang) = count(distinct-values(dcterms:title/@xml:lang)))]">
									<div class="alert-danger alert alert-box">
										<p>
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Title languages must be unique.</p>
									</div>
								</xforms:group>

								<xforms:group ref=".[not(count(dcterms:description/@xml:lang) = count(distinct-values(dcterms:description/@xml:lang)))]">
									<div class="alert-danger alert alert-box">
										<p>
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Description languages must be unique.</p>
									</div>
								</xforms:group>

								<h2>Dataset Metadata</h2>
								<div class="trigger_container">
									<xforms:trigger appearance="minimal">
										<xforms:label>
											<span class="glyphicon glyphicon-plus"></span> Title</xforms:label>
										<xforms:insert ev:event="DOMActivate" context="." nodeset="./child::node()[last()]"
											origin="xforms:element('dcterms:title', (xforms:attribute('xml:lang', '')))"/>
									</xforms:trigger>
									<xforms:trigger appearance="minimal">
										<xforms:label>
											<span class="glyphicon glyphicon-plus"></span> Description</xforms:label>
										<xforms:insert ev:event="DOMActivate" context="." nodeset="./child::node()[last()]"
											origin="xforms:element('dcterms:description', (xforms:attribute('xml:lang', '')))"/>
									</xforms:trigger>
									<xforms:group ref=".[count(dcterms:license) = 0]">
										<xforms:trigger appearance="minimal">
											<xforms:label>
												<span class="glyphicon glyphicon-plus"></span> License</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:insert context="instance('control-instance')" nodeset="./child::node()[last()]"
													origin="xforms:element('license', '')"/>
												<xforms:insert context="." nodeset="./child::node()[last()]"
													origin="xforms:element('dcterms:license', (xforms:attribute('rdf:resource', '')))"/>
											</xforms:action>

										</xforms:trigger>
									</xforms:group>
									<xforms:group ref=".[count(dcterms:rights) = 0]">
										<xforms:trigger appearance="minimal">
											<xforms:label>
												<span class="glyphicon glyphicon-plus"></span> Rights</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:insert context="instance('control-instance')" nodeset="./child::node()[last()]"
													origin="xforms:element('rights', '')"/>
												<xforms:insert context="." nodeset="./child::node()[last()]"
													origin="xforms:element('dcterms:rights', (xforms:attribute('rdf:resource', '')))"/>
											</xforms:action>
										</xforms:trigger>
									</xforms:group>
								</div>

								<div>
									<xforms:input ref="@rdf:about">
										<xforms:label>Dataset URI</xforms:label>
									</xforms:input>
								</div>
								<div>
									<xforms:input ref="void:dataDump/@rdf:resource">
										<xforms:label>JSON-LD URL</xforms:label>
									</xforms:input>
								</div>

								<xforms:repeat nodeset="dcterms:title">
									<div>
										<xforms:input ref=".">
											<xforms:label>Title</xforms:label>
											<xforms:alert>Required</xforms:alert>
										</xforms:input>
										<xforms:select1 ref="@xml:lang">
											<xforms:alert>Required</xforms:alert>
											<xforms:item>
												<xforms:label>Select...</xforms:label>
												<xforms:value/>
											</xforms:item>
											<xforms:itemset nodeset="instance('languages')/language">
												<xforms:label ref="."/>
												<xforms:value ref="@value"/>
											</xforms:itemset>
										</xforms:select1>
										<xforms:group ref=".[count(parent::node()/dcterms:title) &gt; 1]">
											<xforms:trigger appearance="minimal">
												<xforms:delete ev:event="DOMActivate" context="."/>
												<xforms:label>
													<span class="glyphicon glyphicon-remove"></span>
												</xforms:label>
											</xforms:trigger>
										</xforms:group>
									</div>
								</xforms:repeat>

								<xforms:repeat nodeset="dcterms:description">
									<div>
										<xforms:textarea ref=".">
											<xforms:label>Description</xforms:label>
											<xforms:alert>Required</xforms:alert>
										</xforms:textarea>
										<xforms:select1 ref="@xml:lang">
											<xforms:alert>Required</xforms:alert>
											<xforms:item>
												<xforms:label>Select...</xforms:label>
												<xforms:value/>
											</xforms:item>
											<xforms:itemset nodeset="instance('languages')/language">
												<xforms:label ref="."/>
												<xforms:value ref="@value"/>
											</xforms:itemset>
										</xforms:select1>
										<xforms:group ref=".[count(parent::node()/dcterms:description) &gt; 1]">
											<xforms:trigger appearance="minimal">
												<xforms:delete ev:event="DOMActivate" context="."/>
												<xforms:label>
													<span class="glyphicon glyphicon-remove"></span>
												</xforms:label>
											</xforms:trigger>
										</xforms:group>
									</div>
								</xforms:repeat>

								<div>
									<xforms:select1 ref="dcterms:publisher/@rdf:resource">
										<xforms:label>Publisher</xforms:label>
										<xforms:alert>Required</xforms:alert>
										<xforms:item>
											<xforms:label>Select...</xforms:label>
											<xforms:value/>
										</xforms:item>
										<xforms:itemset nodeset="instance('collections')/collection">
											<xforms:label ref="."/>
											<xforms:value ref="@uri"/>
										</xforms:itemset>
									</xforms:select1>
								</div>

								<xforms:group ref="instance('control-instance')">

									<xforms:group ref="license">
										<div>

											<xforms:select1 ref=".">
												<xforms:label>License</xforms:label>
												<xforms:alert>Required</xforms:alert>
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('licenses')/statement">
													<xforms:label ref="."/>
													<xforms:value ref="@value"/>
												</xforms:itemset>
												<xforms:item>
													<xforms:label>Other License (specify)</xforms:label>
													<xforms:value>other</xforms:value>
												</xforms:item>

												<xforms:action ev:event="xforms-value-changed">
													<xforms:var name="val" select="."/>

													<xforms:action if="starts-with($val, 'http')">
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource" value="$val"/>

														<xforms:delete nodeset="instance('control-instance')/license/@other"/>
													</xforms:action>
													<xforms:action if="$val = 'other'">
														<xforms:insert context="instance('control-instance')/license" origin="xforms:attribute('other', '')"/>
													</xforms:action>
													<xforms:action if="not(string($val))">
														<!-- blank values -->
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"/>

														<xforms:delete nodeset="instance('control-instance')/license/@other"/>
													</xforms:action>
												</xforms:action>
											</xforms:select1>

											<xforms:group ref="@other">
												<div>
													<xforms:textarea ref=".">
														<xforms:label>Other License</xforms:label>
														<xforms:alert>Required</xforms:alert>

														<xforms:action ev:event="xforms-value-changed">
															<xforms:var name="val" select="."/>
															<!-- set the @rdf:resource if the value is a URL, otherwise set the literal -->
															<xforms:action if="matches($val, 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$')">
																<!-- insert @rdf:resource if it doesn't already exist -->
																<xforms:insert context="instance('void-rdf')/void:Dataset/dcterms:license"
																	origin="xforms:attribute('rdf:resource', '')"
																	if="not(instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource)"/>

																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"
																	value="$val"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
															</xforms:action>
															<xforms:action if="not(matches($val, 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$'))">
																<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license" value="$val"/>
															</xforms:action>
														</xforms:action>
													</xforms:textarea>
												</div>
											</xforms:group>

											<!-- allow deletion of license if there's a rights -->
											<xforms:group ref=".[count(instance('void-rdf')/void:Dataset/dcterms:rights) &gt; 0]">
												<xforms:trigger appearance="minimal">
													<xforms:label>
														<span class="glyphicon glyphicon-remove"></span>
													</xforms:label>
													<xforms:action ev:event="DOMActivate">
														<xforms:delete nodeset="."/>
														<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:license"/>
													</xforms:action>
												</xforms:trigger>
											</xforms:group>
										</div>
									</xforms:group>

									<xforms:group ref="rights">
										<div>

											<xforms:select1 ref=".">
												<xforms:label>Rights</xforms:label>
												<xforms:alert>Required</xforms:alert>
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('rights')/statement">
													<xforms:label ref="."/>
													<xforms:value ref="@value"/>
												</xforms:itemset>
												<xforms:item>
													<xforms:label>Other Rights (specify)</xforms:label>
													<xforms:value>other</xforms:value>
												</xforms:item>

												<xforms:action ev:event="xforms-value-changed">
													<xforms:var name="val" select="."/>

													<xforms:action if="starts-with($val, 'http')">
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource" value="$val"/>

														<xforms:delete nodeset="instance('control-instance')/rights/@other"/>
													</xforms:action>
													<xforms:action if="$val = 'other'">
														<xforms:insert context="instance('control-instance')/rights" origin="xforms:attribute('other', '')"/>
													</xforms:action>
													<xforms:action if="not(string($val))">
														<!-- blank values -->
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"/>

														<xforms:delete nodeset="instance('control-instance')/rights/@other"/>
													</xforms:action>
												</xforms:action>
											</xforms:select1>

											<xforms:group ref="@other">
												<div>
													<xforms:textarea ref=".">
														<xforms:label>Other Rights</xforms:label>
														<xforms:alert>Required</xforms:alert>

														<xforms:action ev:event="xforms-value-changed">
															<xforms:var name="val" select="."/>
															<!-- set the @rdf:resource if the value is a URL, otherwise set the literal -->
															<xforms:action if="matches($val, 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$')">
																<!-- insert @rdf:resource if it doesn't already exist -->
																<xforms:insert context="instance('void-rdf')/void:Dataset/dcterms:rights"
																	origin="xforms:attribute('rdf:resource', '')"
																	if="not(instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource)"/>

																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"
																	value="$val"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
															</xforms:action>
															<xforms:action if="not(matches($val, 'https?://(-\.)?([^\s/?\.#-]+\.?)+(/[^\s]*)?$'))">
																<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights" value="$val"/>
															</xforms:action>
														</xforms:action>
													</xforms:textarea>
												</div>
											</xforms:group>

											<!-- allow deletion of rights if there's a license -->
											<xforms:group ref=".[count(instance('void-rdf')/void:Dataset/dcterms:license) &gt; 0]">
												<xforms:trigger appearance="minimal">
													<xforms:label>
														<span class="glyphicon glyphicon-remove"></span>
													</xforms:label>
													<xforms:action ev:event="DOMActivate">
														<xforms:delete nodeset="."/>
														<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:rights"/>
													</xforms:action>
												</xforms:trigger>
											</xforms:group>
										</div>
									</xforms:group>

								</xforms:group>

								<xforms:trigger bind="import-json-trigger">
									<xforms:label>Begin Harvest</xforms:label>
									<xforms:action ev:event="DOMActivate">
										<xforms:send submission="load-json"/>

										<!-- if there are errors or warnings, then toggle to the error/warning case -->
										<xforms:action if="count(instance('errors')/error) &gt; 0">
											<xforms:toggle case="error-interface"/>
										</xforms:action>
										<xforms:action if="count(instance('errors')/error) = 0">
											<!-- after the completion of the request, initiate SPARQL publication -->
											<xforms:send submission="post-dump"/>
											<xforms:action ev:event="xforms-submit-done">
												<xforms:send submission="post-void"/>
											</xforms:action>

											<!-- refresh page after dumps have been posted -->
											<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
											<xforms:send submission="submit-sparqlQuery"/>
											<xforms:delete nodeset="instance('datasets')/*"/>
											<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
											<xforms:toggle case="default"/>
										</xforms:action>
									</xforms:action>
								</xforms:trigger>

								<xforms:trigger>
									<xforms:label>Delete Places</xforms:label>
									<xforms:action ev:event="DOMActivate">
										<xforms:setvalue ref="instance('sparqlUpdate')" value="instance('sparqlUpdate-template')/query[@id='delete-places']"/>
										<xforms:send submission="delete-graph"/>
									</xforms:action>
								</xforms:trigger>
							</xforms:group>
						</xforms:case>
						<xforms:case id="validate-void">
							<xforms:group ref="instance('void-rdf')">
								<xforms:group ref="void:Dataset[@rdf:about]">

									<h2>Dataset Metadata</h2>

									<div>
										<xforms:output ref="@rdf:about">
											<xforms:label>URI</xforms:label>
											<xforms:alert>Required</xforms:alert>
										</xforms:output>
									</div>
									<xforms:repeat nodeset="dcterms:title">
										<div>
											<xforms:output ref=".">
												<xforms:label>Title</xforms:label>
											</xforms:output>
											<xforms:group ref="@lang">
												<xforms:output value="concat('(', ., ')')"/>
											</xforms:group>
										</div>
									</xforms:repeat>
									<xforms:repeat nodeset="dcterms:description">
										<div>
											<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
												<xforms:label>Description</xforms:label>
												<xforms:alert>test</xforms:alert>
											</xforms:output>
											<xforms:group ref="@lang">
												<xforms:output value="concat('(', ., ')')"/>
											</xforms:group>
										</div>
									</xforms:repeat>
									<xforms:group ref="dcterms:publisher">
										<div>
											<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
												<xforms:label>Publisher</xforms:label>
											</xforms:output>
										</div>
									</xforms:group>
									<xforms:group ref="dcterms:license">
										<div>
											<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
												<xforms:label>License</xforms:label>
											</xforms:output>
										</div>
									</xforms:group>
									<xforms:group ref="dcterms:rights">
										<div>
											<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
												<xforms:label>License</xforms:label>
											</xforms:output>
										</div>
									</xforms:group>
									<!-- the validate trigger is only enabled when the VoID RDF metadata conforms to basic requirements -->
									<!--<xforms:trigger bind="validate-trigger">
										<xforms:label><span class="glyphicon glyphicon-check"></span>Validate</xforms:label>
										<xforms:action ev:event="DOMActivate">
											<xforms:message level="modal">test</xforms:message>
										</xforms:action>
									</xforms:trigger>-->

									<xforms:trigger>
										<xforms:label><span class="glyphicon glyphicon-upload"></span> Import</xforms:label>
										<xforms:action ev:event="DOMActivate">
											
											<!-- push VoID RDF into triplestore -->
											<xforms:send submission="post-void"/>

											<xforms:action xxforms:iterate="instance('void-rdf')/void:Dataset/void:dataDump">
												<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
												<xforms:send submission="load-dump"/>
												<xforms:send submission="post-dump"/>
											</xforms:action>

											<!-- send the findspot place hierarchy to the triplestore -->
											<xforms:send submission="post-places"/>
											
											<!-- refresh page after dumps have been posted -->
											<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
											<xforms:send submission="submit-sparqlQuery"/>
											<xforms:delete nodeset="instance('datasets')/*"/>
											<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
											<xforms:toggle case="default"/>
										</xforms:action>
									</xforms:trigger>
								</xforms:group>
								<!-- if there is not a void:Dataset child and/or there is no URI for the Dataset, then validation fails outright -->
								<xforms:group ref=".[not(void:Dataset[@rdf:about])]">
									<div class="bg-danger alert-box"><span class="glyphicon glyphicon-exclamation-sign"></span>
										<strong>Alert:</strong> No void:Dataset object or missing dataset URI.</div>
									<xforms:trigger>
										<xforms:label><span class="glyphicon glyphicon-arrow-left"></span> Back</xforms:label>
										<xforms:toggle case="default" ev:event="DOMActivate"/>
									</xforms:trigger>
								</xforms:group>
							</xforms:group>
						</xforms:case>
						<xforms:case id="error-interface">
							<xforms:group ref="instance('errors')">
								<h2>Errors</h2>
								<p>The following data validation errors have occurred in the processing of the JSON-LD API. Please fix this issues before
									attempting to re-harvest the data.</p>
								<ul>
									<xforms:repeat nodeset="error">
										<li><xforms:output ref="."/></li>
									</xforms:repeat>
								</ul>
							</xforms:group>
						</xforms:case>
					</xforms:switch>
					<!--<fr:xforms-inspector/>-->
				</div>
			</div>
		</div>
		<!-- *********** DIALOGS *********** -->
		<!-- this is the dialog for looking up a VoID RDF metadata object -->
		<xxforms:dialog id="lookup-dialog" appearance="full" level="modal" close="true" draggable="true" visible="false">
			<xforms:label>Load VoID RDF</xforms:label>
			<p>Insert the URI for VoID metadata RDF.</p>
			<div>
				<xforms:input ref="instance('control-instance')/void_uri"/>
				<xforms:trigger>
					<xforms:label>Load</xforms:label>
					<!-- delete current options in the instance and initiate new query -->
					<xforms:action ev:event="DOMActivate">
						<xforms:send submission="load-void"/>
						<xforms:action ev:event="xforms-submit-done">
							<xforms:toggle case="validate-void"/>
							<xforms:setvalue ref="instance('control-instance')/validate-trigger" value="true()" if="xxforms:valid(instance('void-rdf'), true())"
							/>
						</xforms:action>
						<xxforms:hide dialog="lookup-dialog"/>
					</xforms:action>
				</xforms:trigger>
			</div>
		</xxforms:dialog>
		<!-- dialog to confirm deletion of a void:Dataset and associated objects -->
		<fr:alert-dialog id="delete-dataset-dialog">
			<fr:label>Delete Dataset</fr:label>
			<fr:message>Are you sure you want to remove this dataset from the Kerameikos.org SPARQL endpoint?</fr:message>
			<fr:positive-choice>
				<fr:label>Yes</fr:label>
				<xforms:action ev:event="DOMActivate">
					<!-- first delete the objects associated with the dataset, linked by void:inDataset -->
					<xforms:setvalue ref="instance('sparqlUpdate')"
						value="replace(instance('sparqlUpdate-template')/query[@id='delete-dump'], 'DATASET', instance('control-instance')/dataset)"/>
					<xforms:send submission="delete-graph"/>
					<!-- then delete the void:Dataset object -->
					<xforms:setvalue ref="instance('sparqlUpdate')"
						value="replace(instance('sparqlUpdate-template')/query[@id='delete-metadata'], 'DATASET', instance('control-instance')/dataset)"/>
					<xforms:send submission="delete-graph"/>
					<!-- resubmit SPARQL query for void:Datasets to reset the table -->
					<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
					<xforms:send submission="submit-sparqlQuery"/>
					<xforms:delete nodeset="instance('datasets')/*"/>
					<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
				</xforms:action>
			</fr:positive-choice>
			<fr:negative-choice>
				<fr:label>No</fr:label>
			</fr:negative-choice>
		</fr:alert-dialog>
		<fr:alert-dialog id="refresh-dataset-dialog">
			<fr:label>Refresh Dataset</fr:label>
			<fr:message>Refreshing the dataset may take several minutes. Continue?</fr:message>
			<fr:positive-choice>
				<fr:label>Yes</fr:label>
				<xforms:action ev:event="DOMActivate">
					<!-- first delete the objects associated with the dataset, linked by void:inDataset -->
					<xforms:setvalue ref="instance('sparqlUpdate')"
						value="replace(instance('sparqlUpdate-template')/query[@id='delete-dump'], 'DATASET', instance('control-instance')/dataset)"/>
					<xforms:send submission="delete-graph"/>
					<!-- then fetch the new data dump -->
					<xforms:action ev:event="xforms-submit-done">
						<xforms:action xxforms:iterate="instance('sparqlResponse')//void:Dataset[@rdf:about=instance('control-instance')/dataset]/void:dataDump">
							<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
							<xforms:send submission="load-dump"/>
							<xforms:send submission="post-dump"/>
						</xforms:action>
						<!-- send the findspot place hierarchy to the triplestore -->
						<xforms:send submission="post-places"/>
						<!-- resubmit SPARQL query for void:Datasets to reset the table -->
						<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
						<xforms:send submission="submit-sparqlQuery"/>
						<xforms:delete nodeset="instance('datasets')/*"/>
						<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
					</xforms:action>
				</xforms:action>
			</fr:positive-choice>
			<fr:negative-choice>
				<fr:label>No</fr:label>
			</fr:negative-choice>
		</fr:alert-dialog>
	</body>
</html>
